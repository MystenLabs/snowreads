{"id":"2408.13779","title":"Concurrent Data Structures Made Easy (Extended Version)","authors":"Callista Le, Kiran Gopinathan, Koon Wen Lee, Seth Gilbert, Ilya Sergey","authorsParsed":[["Le","Callista",""],["Gopinathan","Kiran",""],["Lee","Koon Wen",""],["Gilbert","Seth",""],["Sergey","Ilya",""]],"versions":[{"version":"v1","created":"Sun, 25 Aug 2024 09:13:56 GMT"}],"updateDate":"2024-08-27","timestamp":1724577236000,"abstract":"  Design of an efficient thread-safe concurrent data structure is a balancing\nact between its implementation complexity and performance. Lock-based\nconcurrent data structures, which are relatively easy to derive from their\nsequential counterparts and to prove thread-safe, suffer from poor throughput\nunder even light multi-threaded workload. At the same time, lock-free\nconcurrent structures allow for high throughput, but are notoriously difficult\nto get right and require careful reasoning to formally establish their\ncorrectness.\n  We explore a solution to this conundrum based on batch parallelism, an\napproach for designing concurrent data structures via a simple insight:\nefficiently processing a batch of a priori known operations in parallel is\neasier than optimising performance for a stream of arbitrary asynchronous\nrequests. Alas, batch-parallel structures have not seen wide practical adoption\ndue to (i) the inconvenience of having to structure multi-threaded programs to\nexplicitly group operations and (ii) the lack of a systematic methodology to\nimplement batch-parallel structures as simply as lock-based ones.\n  We present OBatcher-an OCaml library that streamlines the design,\nimplementation, and usage of batch-parallel structures. It solves the first\nchallenge (how to use) by suggesting a new lightweight implicit batching design\nthat is built on top of generic asynchronous programming mechanisms. The second\nchallenge (how to implement) is addressed by identifying a family of strategies\nfor converting common sequential structures into efficient batch-parallel ones.\nWe showcase OBatcher with a diverse set of benchmarks. Our evaluation of all\nthe implementations on large asynchronous workloads shows that (a) they\nconsistently outperform the corresponding coarse-grained lock-based\nimplementations and that (b) their throughput scales reasonably with the number\nof processors.\n","subjects":["Computing Research Repository/Programming Languages","Computing Research Repository/Distributed, Parallel, and Cluster Computing"],"license":"http://creativecommons.org/licenses/by-sa/4.0/","blobId":"Qx8vy3gm8ZWoXF_hgSMPdThlyl_75UUTnLfWjEeZHVs","pdfSize":"4342981"}
