{"id":"2407.09320","title":"Defining Name Accessibility using Scope Graphs (Extended Edition)","authors":"Aron Zwaan, Casper Bach Poulsen","authorsParsed":[["Zwaan","Aron",""],["Poulsen","Casper Bach",""]],"versions":[{"version":"v1","created":"Fri, 12 Jul 2024 14:57:34 GMT"}],"updateDate":"2024-07-15","timestamp":1720796254000,"abstract":"  Many programming languages allow programmers to regulate accessibility; i.e.,\nannotating a declaration with keywords such as export and private to indicate\nwhere it can be accessed. Despite the importance of name accessibility for,\ne.g., compilers, editor auto-completion and tooling, and automated\nrefactorings, few existing type systems provide a formal account of name\naccessibility.\n  We present a declarative, executable, and language-parametric model for name\naccessibility, which provides a formal specification of name accessibility in\nJava, C#, C++, Rust, and Eiffel. We achieve this by defining name accessibility\nas a predicate on resolution paths through scope graphs. Since scope graphs are\na language-independent model of name resolution, our model provides a uniform\napproach to defining different accessibility policies for different languages.\n  Our model is implemented in Statix, a logic language for executable type\nsystem specification using scope graphs. We evaluate its correctness on a test\nsuite that compares it with the C#, Java, and Rust compilers, and show we can\nsynthesize access modifiers in programs with holes accurately.\n","subjects":["Computing Research Repository/Programming Languages"],"license":"http://creativecommons.org/licenses/by/4.0/"}