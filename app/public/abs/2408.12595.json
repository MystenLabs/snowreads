{"id":"2408.12595","title":"Quantum Sabotage Complexity","authors":"Arjan Cornelissen, Nikhil S. Mande, Subhasree Patro","authorsParsed":[["Cornelissen","Arjan",""],["Mande","Nikhil S.",""],["Patro","Subhasree",""]],"versions":[{"version":"v1","created":"Thu, 22 Aug 2024 17:57:58 GMT"}],"updateDate":"2024-08-23","timestamp":1724349478000,"abstract":"  Given a Boolean function $f:\\{0,1\\}^n\\to\\{0,1\\}$, the goal in the usual query\nmodel is to compute $f$ on an unknown input $x \\in \\{0,1\\}^n$ while minimizing\nthe number of queries to $x$. One can also consider a \"distinguishing\" problem\ndenoted by $f_{\\mathsf{sab}}$: given an input $x \\in f^{-1}(0)$ and an input $y\n\\in f^{-1}(1)$, either all differing locations are replaced by a $*$, or all\ndiffering locations are replaced by $\\dagger$, and an algorithm's goal is to\nidentify which of these is the case while minimizing the number of queries.\n  Ben-David and Kothari [ToC'18] introduced the notion of randomized sabotage\ncomplexity of a Boolean function to be the zero-error randomized query\ncomplexity of $f_{\\mathsf{sab}}$. A natural follow-up question is to understand\n$\\mathsf{Q}(f_{\\mathsf{sab}})$, the quantum query complexity of\n$f_{\\mathsf{sab}}$. In this paper, we initiate a systematic study of this. The\nfollowing are our main results:\n  $\\bullet\\;\\;$ If we have additional query access to $x$ and $y$, then\n$\\mathsf{Q}(f_{\\mathsf{sab}})=O(\\min\\{\\mathsf{Q}(f),\\sqrt{n}\\})$.\n  $\\bullet\\;\\;$ If an algorithm is also required to output a differing index of\na 0-input and a 1-input, then\n$\\mathsf{Q}(f_{\\mathsf{sab}})=O(\\min\\{\\mathsf{Q}(f)^{1.5},\\sqrt{n}\\})$.\n  $\\bullet\\;\\;$ $\\mathsf{Q}(f_{\\mathsf{sab}}) =\n\\Omega(\\sqrt{\\mathsf{fbs}(f)})$, where $\\mathsf{fbs}(f)$ denotes the fractional\nblock sensitivity of $f$. By known results, along with the results in the\nprevious bullets, this implies that $\\mathsf{Q}(f_{\\mathsf{sab}})$ is\npolynomially related to $\\mathsf{Q}(f)$.\n  $\\bullet\\;\\;$ The bound above is easily seen to be tight for standard\nfunctions such as And, Or, Majority and Parity. We show that when $f$ is the\nIndexing function, $\\mathsf{Q}(f_{\\mathsf{sab}})=\\Theta(\\mathsf{fbs}(f))$,\nruling out the possibility that\n$\\mathsf{Q}(f_{\\mathsf{sab}})=\\Theta(\\sqrt{\\mathsf{fbs}(f)})$ for all $f$.\n","subjects":["Physics/Quantum Physics","Computing Research Repository/Computational Complexity"],"license":"http://creativecommons.org/licenses/by/4.0/","blobId":"T3TlXXMnWlF3biKxBZvmjIr2d7K8-QyKO6ddUBKLjDM","pdfSize":"285851"}
