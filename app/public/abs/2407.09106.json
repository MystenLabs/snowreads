{"id":"2407.09106","title":"Refinements for Multiparty Message-Passing Protocols:\n  Specification-agnostic theory and implementation","authors":"Vassor Martin and Yoshida Nobuko","authorsParsed":[["Martin","Vassor",""],["Nobuko","Yoshida",""]],"versions":[{"version":"v1","created":"Fri, 12 Jul 2024 09:15:12 GMT"},{"version":"v2","created":"Fri, 9 Aug 2024 09:05:56 GMT"}],"updateDate":"2024-08-12","timestamp":1720775712000,"abstract":"  Multiparty message-passing protocols are notoriously difficult to design, due\nto interaction mismatches that lead to errors such as deadlocks. Existing\nprotocol specification formats have been developed to prevent such errors (e.g.\nmultiparty session types (MPST)). In order to further constrain protocols,\nspecifications can be extended with refinements, i.e. logical predicates to\ncontrol the behaviour of the protocol based on previous values exchanged.\nUnfortunately, existing refinement theories and implementations are tightly\ncoupled with specification formats. This paper proposes a framework for\nmultiparty message-passing protocols with refinements and its implementation in\nRust. Our work decouples correctness of refinements from the underlying model\nof computation, which results in a specification-agnostic framework. Our\ncontributions are threefold. First, we introduce a trace system which\ncharacterises valid refined traces, i.e. a sequence of sending and receiving\nactions correct with respect to refinements. Second, we give a correct model of\ncomputation named refined communicating system (RCS), which is an extension of\ncommunicating automata systems with refinements. We prove that RCS only produce\nvalid refined traces. We show how to generate RCS from mainstream protocol\nspecification formats, such as refined multiparty session types (RMPST) or\nrefined choreography automata. Third, we illustrate the flexibility of the\nframework by developing both a static analysis technique and an improved model\nof computation for dynamic refinement evaluation. Finally, we provide a Rust\ntoolchain for decentralised RMPST, evaluate our implementation with a set of\nbenchmarks from the literature, and observe that refinement overhead is\nnegligible.\n","subjects":["Computing Research Repository/Programming Languages"],"license":"http://creativecommons.org/licenses/by/4.0/"}