{"id":"2407.04917","title":"A Calculus for Unreachable Code","authors":"Peter Zhong and Shu-Hung You and Simone Campanoni and Robert Bruce\n  Findler and Matthew Flatt and Christos Dimoulas","authorsParsed":[["Zhong","Peter",""],["You","Shu-Hung",""],["Campanoni","Simone",""],["Findler","Robert Bruce",""],["Flatt","Matthew",""],["Dimoulas","Christos",""]],"versions":[{"version":"v1","created":"Sat, 6 Jul 2024 01:49:57 GMT"}],"updateDate":"2024-07-09","timestamp":1720230597000,"abstract":"  In Racket, the LLVM IR, Rust, and other modern languages, programmers and\nstatic analyses can hint, with special annotations, that certain parts of a\nprogram are unreachable. Same as other assumptions about undefined behavior;\nthe compiler assumes these hints are correct and transforms the program\naggressively.\n  While compile-time transformations due to undefined behavior often perplex\ncompiler writers and developers, we show that the essence of transformations\ndue to unreachable code can be distilled in a surprisingly small set of simple\nformal rules. Specifically, following the well-established tradition of\nunderstanding linguistic phenomena through calculi, we introduce the first\ncalculus for unreachable. Its term-rewriting rules that take advantage of\nunreachable fall into two groups. The first group allows the compiler to delete\nany code downstream of unreachable, and any effect-free code upstream of\nunreachable. The second group consists of rules that eliminate conditional\nexpressions when one of their branches is unreachable. We show the correctness\nof the rules with a novel logical relation, and we examine how they correspond\nto transformations due to unreachable in Racket and LLVM.\n","subjects":["Computing Research Repository/Programming Languages"],"license":"http://creativecommons.org/licenses/by/4.0/"}