{"id":"2408.14668","title":"Synthesizing Formal Semantics from Executable Interpreters","authors":"Jiangyi Liu, Charlie Murphy, Anvay Grover, Keith J.C. Johnson, Thomas\n  Reps, Loris D'Antoni","authorsParsed":[["Liu","Jiangyi",""],["Murphy","Charlie",""],["Grover","Anvay",""],["Johnson","Keith J. C.",""],["Reps","Thomas",""],["D'Antoni","Loris",""]],"versions":[{"version":"v1","created":"Mon, 26 Aug 2024 22:16:22 GMT"},{"version":"v2","created":"Fri, 30 Aug 2024 02:49:49 GMT"},{"version":"v3","created":"Fri, 6 Sep 2024 20:11:39 GMT"}],"updateDate":"2024-09-10","timestamp":1724710582000,"abstract":"  Program verification and synthesis frameworks that allow one to customize the\nlanguage in which one is interested typically require the user to provide a\nformally defined semantics for the language. Because writing a formal semantics\ncan be a daunting and error-prone task, this requirement stands in the way of\nsuch frameworks being adopted by non-expert users. We present an algorithm that\ncan automatically synthesize inductively defined syntax-directed semantics when\ngiven (i) a grammar describing the syntax of a language and (ii) an executable\n(closed-box) interpreter for computing the semantics of programs in the\nlanguage of the grammar. Our algorithm synthesizes the semantics in the form of\nConstrained-Horn Clauses (CHCs), a natural, extensible, and formal logical\nframework for specifying inductively defined relations that has recently\nreceived widespread adoption in program verification and synthesis. The key\ninnovation of our synthesis algorithm is a Counterexample-Guided Synthesis\n(CEGIS) approach that breaks the hard problem of synthesizing a set of\nconstrained Horn clauses into small, tractable expression-synthesis problems\nthat can be dispatched to existing SyGuS synthesizers. Our tool Synantic\nsynthesized inductively-defined formal semantics from 14 interpreters for\nlanguages used in program-synthesis applications. When synthesizing formal\nsemantics for one of our benchmarks, Synantic unveiled an inconsistency in the\nsemantics computed by the interpreter for a language of regular expressions;\nfixing the inconsistency resulted in a more efficient semantics and, for some\ncases, in a 1.2x speedup for a synthesizer solving synthesis problems over such\na language.\n","subjects":["Computing Research Repository/Programming Languages"],"license":"http://creativecommons.org/licenses/by-sa/4.0/","blobId":"qZFH0BcsLV-Cr9bq76YPw0ysuUujauzFQyzLGVI7y3w","pdfSize":"1028551"}
