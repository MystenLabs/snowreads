{"id":"2408.07652","title":"The Semantics of Metapropramming in Prolog","authors":"David S. Warren","authorsParsed":[["Warren","David S.",""]],"versions":[{"version":"v1","created":"Wed, 14 Aug 2024 16:27:16 GMT"}],"updateDate":"2024-08-15","timestamp":1723652836000,"abstract":"  This paper describes a semantics for pure Prolog programs with negation that\nprovides meaning to metaprograms. Metaprograms are programs that construct and\nuse data structures as programs. In Prolog a primary mataprogramming construct\nis the use of a variable as a literal in the body of a clause. The traditional\nProlog 3-line metainterpreter is another example of a metaprogram. The account\ngiven here also supplies a meaning for clauses that have a variable as head,\neven though most Prolog systems do not support such clauses. This semantics\nnaturally includes such programs, giving them their intuitive meaning.\n  Ideas from M. Denecker and his colleagues form the basis of this approach.\nThe key idea is to notice that if we give meanings to all propositional\nprograms and treat Prolog rules with variables as the set of their ground\ninstances, then we can give meanings to all programs. We must treat Prolog\nrules (which may be metarules) as templates for generating ground propositional\nrules, and not as first-order formulas, which they may not be. We use\nparameterized inductive definitions to give propositional models to Prolog\nprograms, in which the propositions are expressions. Then the set of\nexpressions of a propositional model determine a first-order Herbrand Model,\nproviding a first-order logical semantics for all (pure) Prolog programs,\nincluding metaprograms.\n  We give examples to show the applicability of this theory. We also\ndemonstrate how this theory makes proofs of some important properties of\nmetaprograms very straightforward.\n","subjects":["Computing Research Repository/Programming Languages"],"license":"http://creativecommons.org/licenses/by-nc-nd/4.0/"}