{"id":"2408.06478","title":"Theorem-Carrying-Transaction: Runtime Certification to Ensure Safety for\n  Smart Contract Transactions","authors":"Nikolaj S. Bj{\\o}rner (1), Ashley J. Chen (2), Shuo Chen (1), Yang\n  Chen (1), Zhongxin Guo (1), Tzu-Han Hsu (3), Peng Liu (4), Nanqing Luo (4)\n  ((1) Microsoft Research, (2) New York University Shanghai, (3) Michigan State\n  University, (4) Pennsylvania State University)","authorsParsed":[["Bj√∏rner","Nikolaj S.",""],["Chen","Ashley J.",""],["Chen","Shuo",""],["Chen","Yang",""],["Guo","Zhongxin",""],["Hsu","Tzu-Han",""],["Liu","Peng",""],["Luo","Nanqing",""]],"versions":[{"version":"v1","created":"Mon, 12 Aug 2024 20:27:41 GMT"}],"updateDate":"2024-08-14","timestamp":1723494461000,"abstract":"  Security bugs and trapdoors in smart contracts have been impacting the\nEthereum community since its inception. Conceptually, the 1.45-million\nEthereum's contracts form a single \"gigantic program\" whose behaviors are\ndetermined by the complex reference-topology between the contracts. Can the\nEthereum community be assured that this gigantic program conforms to its\ndesign-level safety properties, despite unforeseeable code-level intricacies?\nStatic code verification is inadequate due to the program's gigantic scale and\nhigh polymorphism. In this paper, we present a viable technological roadmap for\nthe community toward this ambitious goal. Our technology, called\nTheorem-Carrying-Transaction (TCT), combines the benefits of concrete execution\nand symbolic proofs. Under the TCT protocol, every transaction carries a\ntheorem that proves its adherence to the specified properties in the invoked\ncontracts, and the runtime system checks the theorem before executing the\ntransaction. Once a property is specified in a contract, it can be treated\nconfidently as an unconditional guarantee made by the contract. As case\nstudies, we demonstrate that TCT secures token contracts without foreseeing\ncode-level intricacies like integer overflow and reentrancy. TCT is also\nsuccessfully applied to a Uniswap codebase, showcasing a complex decentralized\nfinance (DeFi) scenario. Our prototype incurs a negligible runtime overhead,\ntwo orders of magnitude lower than a state-of-the-art approach.\n","subjects":["Computing Research Repository/Cryptography and Security","Computing Research Repository/Programming Languages"],"license":"http://creativecommons.org/licenses/by/4.0/"}