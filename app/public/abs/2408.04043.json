{"id":"2408.04043","title":"Ownership in low-level intermediate representation","authors":"Siddharth Priya, Arie Gurfinkel","authorsParsed":[["Priya","Siddharth",""],["Gurfinkel","Arie",""]],"versions":[{"version":"v1","created":"Wed, 7 Aug 2024 18:51:07 GMT"},{"version":"v2","created":"Sun, 11 Aug 2024 18:58:35 GMT"},{"version":"v3","created":"Tue, 13 Aug 2024 13:31:34 GMT"}],"updateDate":"2024-08-14","timestamp":1723056667000,"abstract":"  The concept of ownership in high level languages can aid both the programmer\nand the compiler to reason about the validity of memory operations. Previously,\nownership semantics has been used successfully in high level automatic program\nverification to model a reference to data by a first order logic (FOL)\nrepresentation of data instead of maintaining an address map. However,\nownership semantics is not used in low level program verification. We have\nidentified two challenges. First, ownership information is lost when a program\nis compiled to a low level intermediate representation (e.g., in LLVM IR).\nSecond, pointers in low level programs point to bytes using an address map\n(e.g., in unsafe Rust) and thus the verification condition (VC) cannot always\nreplace a pointer by its FOL abstraction. To remedy the situation, we develop\nownership semantics for an LLVM like low level intermediate representation.\nUsing these semantics, the VC can opportunistically model some memory accesses\nby a direct access of a pointer cache that stores byte representation of data.\nThis scheme reduces instances where an address map must be maintained,\nespecially for mostly safe programs that follow ownership semantics. For unsafe\nfunctionality, memory accesses are modelled by operations on an address map and\nwe provide mechanisms to keep the address map and pointer cache in sync. We\nimplement these semantics in SEABMC, a bit precise bounded model checker for\nLLVM. For evaluation, the source programs are assumed to be written in C. Since\nC does not have ownership built in, suitable macros are added that introduce\nand preserve ownership during translation to LLVM like IR for verification.\nThis approach is evaluated on mature open source C code. For both handcrafted\nbenchmarks and practical programs, we observe a speedup of $1.3x-5x$ during SMT\nsolving.\n","subjects":["Computing Research Repository/Programming Languages","Computing Research Repository/Software Engineering"],"license":"http://creativecommons.org/licenses/by/4.0/"}