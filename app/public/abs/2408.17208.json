{"id":"2408.17208","title":"Extending the C/C++ Memory Model with Inline Assembly","authors":"Paulo Em\\'ilio de Vilhena, Ori Lahav, Viktor Vafeiadis, Azalea Raad","authorsParsed":[["de Vilhena","Paulo Em√≠lio",""],["Lahav","Ori",""],["Vafeiadis","Viktor",""],["Raad","Azalea",""]],"versions":[{"version":"v1","created":"Fri, 30 Aug 2024 11:27:33 GMT"},{"version":"v2","created":"Mon, 2 Sep 2024 09:35:11 GMT"}],"updateDate":"2024-09-04","timestamp":1725017253000,"abstract":"  Programs written in C/C++ often include inline assembly: a snippet of\narchitecture-specific assembly code used to access low-level functionalities\nthat are impossible or expensive to simulate in the source language. Although\ninline assembly is widely used, its semantics has not yet been formally\nstudied.\n  In this paper, we overcome this deficiency by investigating the effect of\ninline assembly on the consistency semantics of C/C++ programs. We propose the\nfirst memory model of the C++ Programming Language with support for inline\nassembly for Intel's x86 including non-temporal stores and store fences. We\nargue that previous provably correct compiler optimizations and correct\ncompiler mappings should remain correct under such an extended model and we\nprove that this requirement is met by our proposed model.\n","subjects":["Computing Research Repository/Programming Languages"],"license":"http://creativecommons.org/licenses/by/4.0/","blobId":"eWjXy6GlCJG1tR7YcBwAMK0TduvctA2J-Qru5bcR1mM","pdfSize":"1311173"}
