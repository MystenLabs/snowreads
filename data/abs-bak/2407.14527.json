{"id":"2407.14527","title":"Building Call Graph of WebAssembly Programs via Abstract Semantics","authors":"Mattia Paccamiccio and Franco Raimondi and Michele Loreti","authorsParsed":[["Paccamiccio","Mattia",""],["Raimondi","Franco",""],["Loreti","Michele",""]],"versions":[{"version":"v1","created":"Mon, 8 Jul 2024 09:32:47 GMT"}],"updateDate":"2024-07-23","timestamp":1720431167000,"abstract":"  WebAssembly is a binary format for code that is gaining popularity thanks to\nits focus on portability and performance. Currently, the most common use case\nfor WebAssembly is execution in a browser. It is also being increasingly\nadopted as a stand-alone application due to its portability. The binary format\nof WebAssembly, however, makes it prone to being used as a vehicle for\nmalicious software. For instance, one could embed a cryptocurrency miner in\ncode executed by a browser. As a result, there is substantial interest in\ndeveloping tools for WebAssembly security verification, information flow\ncontrol, and, more generally, for verifying behavioral properties such as\ncorrect API usage. In this document, we address the issue of building call\ngraphs for WebAssembly code. This is important because having or computing a\ncall graph is a prerequisite for most inter-procedural verification tasks. In\nthis paper, we propose a formal solution based on the theory of Abstract\nInterpretation. We compare our approach to the state-of-the-art by predicting\nhow it would perform against a set of specifically crafted benchmark programs.\n","subjects":["Computing Research Repository/Software Engineering","Computing Research Repository/Cryptography and Security"],"license":"http://creativecommons.org/licenses/by/4.0/","blobId":"j2Y4SvIh4zbxNwymiB8vjpKJxwuRMb0N764uehbN_Yk","pdfSize":"682544","objectId":"0x3c9cc669abd053b2538798a0891cbd27007a630cd9ff443a5848d89cc2150d45","registeredEpoch":"1","certifiedEpoch":"1","startEpoch":"1","endEpoch":"201"}
