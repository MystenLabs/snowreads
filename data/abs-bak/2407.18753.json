{"id":"2407.18753","title":"On Computing the Smallest Suffixient Set","authors":"Davide Cenzato, Francisco Olivares and Nicola Prezza","authorsParsed":[["Cenzato","Davide",""],["Olivares","Francisco",""],["Prezza","Nicola",""]],"versions":[{"version":"v1","created":"Fri, 26 Jul 2024 14:08:53 GMT"}],"updateDate":"2024-07-29","timestamp":1722002933000,"abstract":"  Let T in \\Sigma^n be a text over alphabet \\Sigma. A suffixient set S\n\\subseteq [n] for T is a set of positions such that, for every one-character\nright-extension T[i,j] of every right-maximal substring T[i,j-1] of T, there\nexists x in S such that T[i,j] is a suffix of T[1,x]. It was recently shown\nthat, given a suffixient set of cardinality q and an oracle offering fast\nrandom access on T (for example, a straight-line program), there is a data\nstructure of O(q) words (on top of the oracle) that can quickly find all\nMaximal Exact Matches (MEMs) of any query pattern P in T with high probability.\nThe paper introducing suffixient sets left open the problem of computing the\nsmallest such set; in this paper, we solve this problem by describing a simple\nquadratic-time algorithm, a O(n + \\bar r|\\Sigma|)-time algorithm running in\ncompressed working space (\\bar r is the number of runs in the Burrows-Wheeler\ntransform of T reversed), and an optimal O(n)-time algorithm computing the\nsmallest suffixient set. We present an implementation of our compressed-space\nalgorithm and show experimentally that it uses a small memory footprint on\nrepetitive text collections.\n","subjects":["Computing Research Repository/Data Structures and Algorithms"],"license":"http://creativecommons.org/licenses/by/4.0/","blobId":"go1PDfgzyN_Ep4A1Jd_Jx5St41mg1GOcUN96c8nk_gE","pdfSize":"664583","objectId":"0xe3302e15290d39bce58a9136455dc1b03ea0231b13ed41f83e4cea8700cc368c","registeredEpoch":"2","certifiedEpoch":"2","startEpoch":"2","endEpoch":"202"}
