{"id":"2407.03685","title":"Verifying Peephole Rewriting In SSA Compiler IRs","authors":"Siddharth Bhat, Alex Keizer, Chris Hughes, Andr\\'es Goens, Tobias\n  Grosser","authorsParsed":[["Bhat","Siddharth",""],["Keizer","Alex",""],["Hughes","Chris",""],["Goens","Andr√©s",""],["Grosser","Tobias",""]],"versions":[{"version":"v1","created":"Thu, 4 Jul 2024 07:16:51 GMT"}],"updateDate":"2024-07-08","timestamp":1720077411000,"abstract":"  There is an increasing need for domain-specific reasoning in modern\ncompilers. This has fueled the use of tailored intermediate representations\n(IRs) based on static single assignment (SSA), like in the MLIR compiler\nframework. Interactive theorem provers (ITPs) provide strong guarantees for the\nend-to-end verification of compilers (e.g., CompCert). However, modern\ncompilers and their IRs evolve at a rate that makes proof engineering alongside\nthem prohibitively expensive. Nevertheless, well-scoped push-button automated\nverification tools such as the Alive peephole verifier for LLVM-IR gained\nrecognition in domains where SMT solvers offer efficient (semi) decision\nprocedures. In this paper, we aim to combine the convenience of automation with\nthe versatility of ITPs for verifying peephole rewrites across domain-specific\nIRs. We formalize a core calculus for SSA-based IRs that is generic over the IR\nand covers so-called regions (nested scoping used by many domain-specific IRs\nin the MLIR ecosystem). Our mechanization in the Lean proof assistant provides\na user-friendly frontend for translating MLIR syntax into our calculus. We\nprovide scaffolding for defining and verifying peephole rewrites, offering\ntactics to eliminate the abstraction overhead of our SSA calculus. We prove\ncorrectness theorems about peephole rewriting, as well as two classical program\ntransformations. To evaluate our framework, we consider three use cases from\nthe MLIR ecosystem that cover different levels of abstractions: (1) bitvector\nrewrites from LLVM, (2) structured control flow, and (3) fully homomorphic\nencryption. We envision that our mechanization provides a foundation for\nformally verified rewrites on new domain-specific IRs.\n","subjects":["Computing Research Repository/Programming Languages","Computing Research Repository/Logic in Computer Science"],"license":"http://creativecommons.org/licenses/by/4.0/","blobId":"tJmVnDysShOIVj9UQDB4zzACMYy4Dqsd6pztJnaRJbA","pdfSize":"690007"}