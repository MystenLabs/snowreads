{"id":"2407.00941","title":"Full Iso-recursive Types","authors":"Litao Zhou, Qianyong Wan and Bruno C. d. S. Oliveira","authorsParsed":[["Zhou","Litao",""],["Wan","Qianyong",""],["Oliveira","Bruno C. d. S.",""]],"versions":[{"version":"v1","created":"Mon, 1 Jul 2024 03:48:32 GMT"},{"version":"v2","created":"Sun, 7 Jul 2024 06:33:23 GMT"}],"updateDate":"2024-07-09","timestamp":1719805712000,"abstract":"  There are two well-known formulations of recursive types: iso-recursive and\nequi-recursive types. Abadi and Fiore [1996] have shown that iso- and\nequi-recursive types have the same expressive power. However, their encoding of\nequi-recursive types in terms of iso-recursive types requires explicit\ncoercions. These coercions come with significant additional computational\noverhead, and complicate reasoning about the equivalence of the two\nformulations of recursive types.\n  This paper proposes a generalization of iso-recursive types called full\niso-recursive types. Full iso-recursive types allow encoding all programs with\nequi-recursive types without computational overhead. Instead of explicit term\ncoercions, all type transformations are captured by computationally irrelevant\ncasts, which can be erased at runtime without affecting the semantics of the\nprogram. Consequently, reasoning about the equivalence between the two\napproaches can be greatly simplified. We present a calculus called\n$\\lambda^{\\mu}_{Fi}$, which extends the simply typed lambda calculus (STLC)\nwith full iso-recursive types. The $\\lambda^{\\mu}_{Fi}$ calculus is proved to\nbe type sound, and shown to have the same expressive power as a calculus with\nequi-recursive types. We also extend our results to subtyping, and show that\nequi-recursive subtyping can be expressed in terms of iso-recursive subtyping\nwith cast operators.\n","subjects":["Computing Research Repository/Programming Languages"],"license":"http://creativecommons.org/licenses/by/4.0/","blobId":"NM4rTMaK2x3k3dkh3hfKdBbE6xRqTTXx-qBos6f9OcY","pdfSize":"428863"}