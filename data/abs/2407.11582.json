{"id":"2407.11582","title":"Reducing Tail Latencies Through Environment- and Neighbour-aware Thread\n  Management","authors":"Andrew Jeffery, Chris Jensen, Richard Mortier","authorsParsed":[["Jeffery","Andrew",""],["Jensen","Chris",""],["Mortier","Richard",""]],"versions":[{"version":"v1","created":"Tue, 16 Jul 2024 10:45:07 GMT"}],"updateDate":"2024-07-17","timestamp":1721126707000,"abstract":"  Application tail latency is a key metric for many services, with high\nlatencies being linked directly to loss of revenue. Modern deeply-nested\nmicro-service architectures exacerbate tail latencies, increasing the\nlikelihood of users experiencing them. In this work, we show how CPU\novercommitment by OS threads leads to high tail latencies when applications are\nunder heavy load. CPU overcommitment can arise from two operational factors:\nincorrectly determining the number of CPUs available when under a CPU quota,\nand the ignorance of neighbour applications and their CPU usage. We discuss\ndifferent languages' solutions to obtaining the CPUs available, evaluating the\nimpact, and discuss opportunities for a more unified language-independent\ninterface to obtain the number of CPUs available. We then evaluate the impact\nof neighbour usage on tail latency and introduce a new neighbour-aware\nthreadpool, the friendlypool, that dynamically avoids overcommitment. In our\nevaluation, the friendlypool reduces maximum worker latency by up to\n$6.7\\times$ at the cost of decreasing throughput by up to $1.4\\times$.\n","subjects":["Computing Research Repository/Distributed, Parallel, and Cluster Computing","Computing Research Repository/Performance"],"license":"http://creativecommons.org/licenses/by/4.0/","blobId":"6r7gnlV-Q7lraVPg9MyCWPwlxpY_h3q_ANfP7IUnlhk","pdfSize":"420358"}