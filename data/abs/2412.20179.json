{
  "id": "2412.20179",
  "title": "A Priori Loop Nest Normalization: Automatic Loop Scheduling in Complex\n  Applications",
  "authors": "Lukas Tr\\\"umper, Philipp Schaad, Berke Ates, Alexandru Calotoiu,\n  Marcin Copik and Torsten Hoefler",
  "authorsParsed": [
    [
      "Tr√ºmper",
      "Lukas",
      ""
    ],
    [
      "Schaad",
      "Philipp",
      ""
    ],
    [
      "Ates",
      "Berke",
      ""
    ],
    [
      "Calotoiu",
      "Alexandru",
      ""
    ],
    [
      "Copik",
      "Marcin",
      ""
    ],
    [
      "Hoefler",
      "Torsten",
      ""
    ]
  ],
  "versions": [
    {
      "version": "v1",
      "created": "Sat, 28 Dec 2024 15:26:57 GMT"
    }
  ],
  "updateDate": "2024-12-31",
  "timestamp": 1735399617000,
  "abstract": "  The same computations are often expressed differently across software\nprojects and programming languages. In particular, how computations involving\nloops are expressed varies due to the many possibilities to permute and compose\nloops. Since each variant may have unique performance properties, automatic\napproaches to loop scheduling must support many different optimization recipes.\nIn this paper, we propose a priori loop nest normalization to align loop nests\nand reduce the variation before the optimization. Specifically, we define and\napply normalization criteria, mapping loop nests with different memory access\npatterns to the same canonical form. Since the memory access pattern is\nsusceptible to loop variations and critical for performance, this normalization\nallows many loop nests to be optimized by the same optimization recipe. To\nevaluate our approach, we apply the normalization with optimizations designed\nfor only the canonical form, improving the performance of many different loop\nnest variants. Across multiple implementations of 15 benchmarks using different\nlanguages, we outperform a baseline compiler in C on average by a factor of\n$21.13$, state-of-the-art auto-schedulers such as Polly and the Tiramisu\nauto-scheduler by $2.31$ and $2.89$, as well as performance-oriented\nPython-based frameworks such as NumPy, Numba, and DaCe by $9.04$, $3.92$, and\n$1.47$. Furthermore, we apply the concept to the CLOUDSC cloud microphysics\nscheme, an actively used component of the Integrated Forecasting System,\nachieving a 10% speedup over the highly-tuned Fortran code.\n",
  "subjects": [
    "Computer Science/Performance"
  ],
  "license": "http://creativecommons.org/licenses/by/4.0/",
  "blobId": "JKBTyGqmsAL8e5VOJCrfyytsnOd48bbc5rfBjoRYPRE",
  "pdfSize": "1946103"
}