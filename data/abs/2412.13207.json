{"id":"2412.13207","title":"Performance Debugging through Microarchitectural Sensitivity and\n  Causality Analysis","authors":"Alban Dutilleul, Hugo Pompougnac, Nicolas Derumigny, Gabriel\n  Rodriguez, Valentin Trophime, Christophe Guillon, and Fabrice Rastello","authorsParsed":[["Dutilleul","Alban",""],["Pompougnac","Hugo",""],["Derumigny","Nicolas",""],["Rodriguez","Gabriel",""],["Trophime","Valentin",""],["Guillon","Christophe",""],["Rastello","Fabrice",""]],"versions":[{"version":"v1","created":"Tue, 3 Dec 2024 11:58:31 GMT"}],"updateDate":"2024-12-19","timestamp":1733227111000,"abstract":"  Modern Out-of-Order (OoO) CPUs are complex systems with many components\ninterleaved in non-trivial ways. Pinpointing performance bottlenecks and\nunderstanding the underlying causes of program performance issues are critical\ntasks to fully exploit the performance offered by hardware resources.\n  Current performance debugging approaches rely either on measuring resource\nutilization, in order to estimate which parts of a CPU induce performance\nlimitations, or on code-based analysis deriving bottleneck information from\ncapacity/throughput models. These approaches are limited by instrumental and\nmethodological precision, present portability constraints across different\nmicroarchitectures, and often offer factual information about resource\nconstraints, but not causal hints about how to solve them.\n  This paper presents a novel performance debugging and analysis tool that\nimplements a resource-centric CPU model driven by dynamic binary\ninstrumentation that is capable of detecting complex bottlenecks caused by an\ninterplay of hardware and software factors. Bottlenecks are detected through\nsensitivity-based analysis, a sort of model parameterization that uses\ndifferential analysis to reveal constrained resources. It also implements a new\ntechnique we developed that we call causality analysis, that propagates\nconstraints to pinpoint how each instruction contribute to the overall\nexecution time.\n  To evaluate our analysis tool, we considered the set of high-performance\ncomputing kernels obtained by applying a wide range of transformations from the\nPolybench benchmark suite and measured the precision on a few Intel CPU and Arm\nmicro-architectures. We also took one of the benchmarks (correlation) as an\nillustrative example to illustrate how our tool's bottleneck analysis can be\nused to optimize a code.\n","subjects":["Computer Science/Distributed, Parallel, and Cluster Computing","Computer Science/Performance"],"license":"http://creativecommons.org/licenses/by/4.0/","blobId":"Xu_mCjOgMot5-EsMt9Fj0GlteHYrJ4gql5EnLA-Imb8","pdfSize":"752995"}